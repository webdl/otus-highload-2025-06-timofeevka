# Масштабируемая подсистема диалогов

## Оглавление

- [Подготовка](#подготовка)
    - [азработка архитектуры сервиса диалогов](#разработка-архитектуры-сервиса-диалогов)
    - [Переосмысление авторизации](#переосмысление-авторизации)
- [Будущие улучшения](#будущие-улучшения)
- [Реализация сервиса диалогов](#реализация-сервиса-диалогов)
  - [Критический путь](#критический-путь)
  - [Альтернативные пути](#альтернативные-пути)
  - [Шардирование сообщений](#шардирование-сообщений)

## Подготовка

### Разработка архитектуры сервиса диалогов

С целью систематизации разрабатываемых сервисов было принято решение сделать шаг назад и проработать архитектуру всего продукта.
Всё началось с выделения бизнес-контекста, целей, стейкхолдеров и составления первичных бизнес-требований. Подробнее про это вы можете
почитать в разделе документации [arch](../doc/arch). Этот документ ложится в основу как ранее созданных сервисов, так и нового сервиса
диалогов.

Вторым этапом я описал по модели C4 первые 3 уровня всех микросервисов (за исключением user-service). Это позволило спроектировать
взаимодействие компонентов сервиса, а дальше оставалось дело техники — написание самого кода.

Схема для сервиса диалогов выглядит следующим образом:

![C3-chats-service.svg](../doc/arch/c4/C3-chats-service.svg)

Данная схема достаточно подробно описывает связи компонентов, но всё еще скрывает детали реализации, описываемые на 4-м уровне модели C4,
что мне и требовалось. Так, например, если сравнивать ее с кодом [chat-service](../chat-service), вы непременно найдете компонены с
одинаковыми именами и связи между ними будут выстроены согласно схеме. Но это будет лишь часть классов, которые потребовались для
создания сервиса диалогов.

### Переосмысление авторизации

В предыдущих версиях продукта я делал публичное REST API, в которое можно обращаться без авторизации. Предполагалось, что сервис
аутентификации будет пропускать только авторизованные запросы к таким сервисам. Этот подход претерпел важное изменение: вместо публичного
API, или необходимости передавать в каждом теле запроса идентификатор пользователя, я поместил его в заголовки запроса (headers). Таким
образом задача сервиса аутентификации "обоготить" запрос от пользователя дополнительными заголовками и направить его дальше.

С точки зрения кода такой подход прост и лаконичен, ведь разработчику достаточно использовать аннотацию чтения заголовком чтобы
гарантировать авторизованный доступ к своему сервису.

## Будущие улучшения

На проектирование и реализацию сервиса ушло немало времени. Была проделана большая работа по изучению материалов по построению системы
диалогов с точки зрения архитектуры и реализации, поэтому не всё задуманное удалось реализовать. Список ниже содержит перечень улучшений
функциональности, надежности и производительности, которые не влияют на домашнее задание, но могли бы быть сделаны в будущем:

1. Мониторинг MongoDB в Grafana
2. Механизм применеия схемы данных из кода в MongoDB
3. Мета-информация для каждого пользователя по их чатам (непрочитанные сообщения и т.п.)
4. Кэширование: сообщений в чатах, мета-информации о чатах
5. Пагинация сообщений в чатах
6. Групповые чаты
7. Улучшенный механизм борьбы с "эффектом Леди Гаги", включая пагинацию и сортировку сообщений
8. Добавить авторизацию в MongoDB
9. Пересылка сообщений между чатами
10. Пакетная обработка сообщений (операции удаления и пересылки)

## Реализация сервиса диалогов

Сервис диалогов состоит из двух ключевых API:

Управление чатами ([ChatController.java](../chat-service/src/main/java/ru/webdl/otus/socialnetwork/infra/chat/ChatController.java)):

```
POST     /chats           # Создать новый чат
GET      /chats           # Получить список чатов пользователя
DELETE   /chats/{chatId}  # Удалить чат
```

Управление
сообщениями ([MessageController.java](../chat-service/src/main/java/ru/webdl/otus/socialnetwork/infra/message/MessageController.java)):

```
POST     /chats/{chatId}/messages          # Отправить сообщение
GET      /chats/{chatId}/messages          # Прочитать все сообщения
PUT      /chats/{chatId}/messages/{msgId}  # Изменить сообщение
DELETE   /chats/{chatId}/messages/{msgId}  # Удалить сообщение
```

В файле [postman_collection.json](../user-service/src/test/postman/postman_collection.json) перечислены все доступные вызовы API.

Запросы через REST-контроллеры идут из слоя инфраструктуры в доменный слой, где происходит обработка бизнес-логики — это реализация
[Чистой архитектуры](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html). Преимущества этого подхода хорошо
прослеживается при сравнении файлов из разных слоев:

- Домен: [MessageImpl.java](../chat-service/src/main/java/ru/webdl/otus/socialnetwork/core/message/MessageImpl.java)
- Инфра: [MongoMessage.java](../chat-service/src/main/java/ru/webdl/otus/socialnetwork/infra/message/MongoMessage.java)

где объект "сообщение" из бизнес-слоя содержит только необходимые для бизнес-логики поля, а его проекция в слое инфраструктуры знает
детали реализации шардирования и хранения данных в MongoDB.

### Критический путь

При начале диалога между двумя пользователями фронтенд посылает запрос на создание нового чата в
[MessageCreationUseCase.java](../chat-service/src/main/java/ru/webdl/otus/socialnetwork/core/message/MessageCreationUseCase.java). На этом
этапе может выполняться проверка прав на чат, Event Driven уведомления и другая бизнес-логика.

Сообщения в чат отправляются
через [MessageCreationUseCase.java](../chat-service/src/main/java/ru/webdl/otus/socialnetwork/core/message/MessageCreationUseCase.java)
где также может выполняться дополнительная бизнес-логика, а сейчас на этом этапе выполняется главное:

1. Определяется ключ шардирования для снижения "эффекта Леди Гаги" (об этом далее)
2. В мета-информации чата сохраняется последнее сообщение для его сортировки и отображения в списке чатов собеседника
3. Сообщение сохраняется в БД

### Альтернативные пути

Реализовано:

1. Редактирование и удаление сообщений с обновлением мета-информации
2. Удаление чатов

### Шардирование сообщений

В самом простом виде шардировать сообщения в MongoDB можно по атрибуту `chatId` — это удобно потому, что на каждом шарде будет храниться
вся история одного чата. Обратной стороной этого подхода является "эффект Леги Гаги", когда чаты с большим количеством сообщений хранятся
на одном шарде, тем самым нагружая его сильнее других шардов.

Для решения этой проблемы применяется различные подходы:

1. Buckets: сообщения записываются в так называется бакеты, которые вмещают в себя ограниченное количество сообщений (например: не
   более 10,000). Ключем шардирования выступает UUID бакета. Альтернативой может выступать реализация, когда сообщения по структуре данных
   не находятся в бакетах, но имеет его ID в теле.
2. Time range: сообщения бьются на временные диапазоны: неделя, месяц и т.д. Ключем шардирования выступает диапазон.
3. Гибридная комбинации подходов выше, в зависимости от решаемых проблем (пагинация, быстрый доступ к последним сообщениям и т.д.)

**Интересно знать**, что в крупных системах, по типу Telegram, используется сложная гибридная архитектуру хранения сообщений, которая
разработана под высокую производительность и оптимальную стоимость:

```
1. RAM Cache → Горячие диалоги и активные чаты
2. SSD Storage → Недавние сообщения (последние 1-3 месяца)
3. HDD Archive → Исторические данные (старые сообщения)
4. Cold Storage → Очень старые данные (редко запрашиваемые)
```

Поэтому решение подобной задачи требует тщательной проработки.

В моем случае я остановился на комбинации `chat UUID + Time range`, где `Time range` выполнен в формате `yyMMddHH` от даты создания
сообщения, то есть меняется каждый час. Данный shard key вычисляется для каждого нового сообщения и помещается в переменную `compositeHash`.
Пример: `4b9f2cca-5bde-41cc-96e8-8891f4e58036|25101404`. 

Код реализации находится в 
[MongoMessageEventListener.java](../chat-service/src/main/java/ru/webdl/otus/socialnetwork/infra/message/MongoMessageEventListener.java).

Чтобы шардирование заработало в MongoDB необходимо подключиться к нашему серверу через консоль (напр. в MongoDB Compass) и выполнить
команды:

```mongodb-json
use chatdb
sh.enableSharding("chatdb")
sh.shardCollection("chatdb.messages", {"compositeHash": "hashed"})
```

Это создаст hash-индекс для данного поля и переведет БД в режим шардирования.

После добавления нескольких сообщений можно выполнить команду ниже и убедиться, что сообщения распределяются по шардам:

```mongodb-json
db.messages.getShardDistribution()

Shard shard1 at shard1/mongoshard11:27017,mongoshard12:27017,mongoshard13:27017
{
  data: '11KiB',
  docs: 44,
  chunks: 1,
  'estimated data per chunk': '11KiB',
  'estimated docs per chunk': 44
}
Shard shard2 at shard2/mongoshard21:27017,mongoshard22:27017,mongoshard23:27017
{
  data: '11KiB',
  docs: 41,
  chunks: 1,
  'estimated data per chunk': '11KiB',
  'estimated docs per chunk': 41
}
Totals
{
  data: '22KiB',
  docs: 85,
  chunks: 2,
  'Shard shard1': [
    '49.69 % data',
    '51.76 % docs in cluster',
    '262B avg obj size on shard'
  ],
  'Shard shard2': [
    '50.3 % data',
    '48.23 % docs in cluster',
    '285B avg obj size on shard'
  ]
}
```

